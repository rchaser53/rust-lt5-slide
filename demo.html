<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js – The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <p style="font-size:60px;">rustでllvm-ir(hello world編)</p>
          <p><a href="https://twitter.com/rChaser53">@rchaser53</a></p>
          <img alt="" src="./img/neko.jpg" />
        </section>

        <section style="text-align:left;" data-markdown>
          - [llvm-sys.rs](https://github.com/tari/llvm-sys.rs)を用いてllvm-irでhello worldする話です
          - 思いの外hello worldまで長かったので書きました
          - プリントデバッグに必要な知識だから仕方ないね
          - llvm-irをこれから触る方の足しになれば幸いです
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 50px; font-weight:bold;">LLVMとは?</p>
            <p>コンパイラ基盤を作るプロジェクト</p>
            <p>ツールチェーンやコンパイラ、モジュールなどを提供</p>
            <p>RustもLLVMを使用している</p>
            
            <p style="text-align:center;">
              <img alt="" src="./img/RetargetableCompiler.png" />
            </p>
          </script>
        </section>

        <section>
          <section style="text-align:left;" data-markdown>
            ### LLVM IRとは?
            - LLVMはThree-stage compiler structureを採用している
            - LLVM IRは各フェイズ間のデータのやりとりに使う
          </section>

          <section style="text-align:left;" data-markdown>
            ### Three-stage compiler structure
            複数のフェイズに分けて開発するコンパイラの設計方法
            
            - フロントエンド
              - パース, エラーチェック、ASTの生成など
            - ミドルエンド(Optimizer)
              - 最適化、高速化など
            - バックエンド
              - 各プラットフォーム向けの最終産物の生成など
            
            IRを用いて各フェイズでデータのやり取りをする
          </section>

          <section style="text-align:left;" data-markdown>
            ### LLVM IRとは?
            
            こんな感じで各フェイズ間のデータのやりとりに使う
            
            ![](./img/LLVMCompiler1.png)

            - 以下でRustでも見れる
              - cargo rustc -- --emit=llvm-ir
          </section>
        </section>

        <section>
          <section style="text-align:left;" data-markdown>
            ### 背景
            - [Go言語でつくるインタプリタ](https://www.oreilly.co.jp/books/9784873118222/)をRustで書いてる
            - [もうやった人いる](https://github.com/tsuyoshiwada/rs-monkey-lang)
            - じゃあ改良して任意のLLVM IRを出力してみよう
          </section>

          <section style="text-align:left;" data-markdown>
            ### 背景
            - hello worldまでの道のりが辛い
            - 資料らしい資料がない
            - では自分で書こう(イマココ)
          </section>
        </section>

        <section style="text-align:left; width:100%; display:block;" data-markdown>
          ### 何を使うの?
            - [llvm-sys.rs](https://github.com/tari/llvm-sys.rs)というLLVM IRを出力するモジュールを使う
            - LLVMはLLVM IRを出力するモジュールを提供している
            - CとC++版がありllvm-sys.rsはC版をbindingしている
        </section>

        <section style="text-align:left; width:100%; display:block;" data-markdown>
          ### llvm-sys.rs
            - 非常に薄い。ほとんどCのAPIと大差ない
            - ドキュメントやサンプルはほぼない
            - CのAPIに関しても少ない。C++ならいくらか
            - 困ったら[ponyc](https://github.com/ponylang/ponyc)を見に行くのをオススメ
        </section>

        <section style="text-align:left; width:100%; display:block;" data-markdown>
          ### 何が難しい?
            - GetElementPtr(GEP)が難しいと思う
            - LLVM IR上で直にいじるのにも慣れがいる
            - [公式の専用の解説ページ](https://llvm.org/docs/GetElementPtr.html)まである
            - CのAPIやリファレンスが正直わかりにくいのも原因
        </section>


        <section>
          <section style="text-align:left;" data-markdown>
            ### GEP(GetElementPtr)とは
            - ArraysやStructsのsubelementのアドレスを取得する
            - つまりArraysやStructsを操作には必須となる
            - 文字列はi8のArray。hello worldするにはこいつが必要
          </section>
        </section>

        <section>
          <section style="text-align:left;" data-markdown>
            ### まずはLLVM IRで出力できるようにする
            
            - 拡張子はll。test.llとか作れば良い
            - LLVMのツールチェーンであるlliを用いて実行すると楽

            ```
              $ lli test.ll
            ```
            
          </section>

          <section style="text-align:left; width:100%; display:block;" data-markdown>
            多分の最小の構成
            ```
            define i32 @main(i32, i8**) {

            entry:
              %local_str = alloca [12 x i8]
              store [12 x i8] c"hello world\00", [12 x i8]* %local_str
              %input_puts = getelementptr [12 x i8], [12 x i8]* %local_str, i32 0, i32 0
              call i32 @printf(i8* %input_puts)
            
              ret i32 0
            }

            declare i32 @printf(i8*)
            ```
          </section>

          <section style="text-align:left; width:100%; display:block;" data-markdown>
            解説1

            ```
            ; 頭文字に;がつくとその行はコメント
            ; @xxxでグローバル変数、 %yyyでローカル変数または型

            ; 戻り値の型 関数名(引数の型1, 引数の型2)
            define i32 @main(i32, i8**) {
              
            ; エントリポイントとなるラベル。必須
            entry:
              %local_str = alloca [12 x i8]
              store [12 x i8] c"hello world\00", [12 x i8]* %local_str
              %input_puts = getelementptr [12 x i8], [12 x i8]* %local_str, i32 0, i32 0
              call i32 @printf(i8* %input_puts)
            
              ret i32 0
            }

            
            declare i32 @printf(i8*)
            ```
          </section>

          <section style="text-align:left; width:100%; display:block;" data-markdown>
              解説2
  
              ```
              define i32 @main(i32, i8**) {

              entry:
                ; レジスタ上に初期化する
                ; [12 x i8]は要素が12のArray
                %local_str = alloca [12 x i8]

                ; レジスタに値を設定する
                ; 基本的に「型 値」みたいな形で記述する
                ; (例) [12 x i8] c"hello world\00"
                store [12 x i8] c"hello world\00", [12 x i8]* %local_str

                ; getelementptr(後述)
                %input_puts = getelementptr [12 x i8], [12 x i8]* %local_str, i32 0, i32 0
                call i32 @printf(i8* %input_puts)
              
                ret i32 0
              }
  
              
              declare i32 @printf(i8*)
              ```
          </section>

          <section style="text-align:left; width:100%; display:block;" data-markdown>
              解説3

              ```
              define i32 @main(i32, i8**) {

              entry:
                %local_str = alloca [12 x i8]
                store [12 x i8] c"hello world\00", [12 x i8]* %local_str
                %input_puts = getelementptr [12 x i8], [12 x i8]* %local_str, i32 0, i32 0

                ; 関数呼び出し
                call i32 @printf(i8* %input_puts)
                
                ; return
                ret i32 0
              }

              ; 標準ライブラリから呼び出す関数を指定
              declare i32 @printf(i8*)
              ```
          </section>
        </section>


        <section>
            <section style="text-align:left;" data-markdown>
              ### LLVM IRのGEP
              
              - ArrayやStructのsubelementのアドレスを取得する
              - 引数のパターンはいくらかある
              - llvm-sys.rsから出力できないパターンは割愛

              ```
                ; 型, 型のポインタ 変数, index1, index2, ...(以下状況によって変更)
                getelementptr %[12 x i8], %[12 x i8]* %local_str, i32 0, i32 0
              ```

              型, 型のポインタはわかるけど、indexは何?

              => ArrayやStructで考えてみる
            </section>

            <section style="text-align:left;" data-markdown>
                ### LLVM IRのGEP(Array)

                ```
                // こんな感じのArrayの値が取得したい
                int temp_array[4][4];
                temp_array[1][3];
                ```

                ```
                  ; グローバルで上記の型を宣言
                  %array_type = type [4 x [4 x i8]]

                  define i8* @test_array_gep(%array_type* %a) {
                    entry:
                      %ret_val = getelementptr %array_type, %array_type* %a, i32 0, i32 1, i32 3
                      ret i8* %ret_val
                  }
                ```
              </section>

              <section style="text-align:left;" data-markdown>
                ### LLVM IRのGEP(Struct)

                ```
                // こんな感じのStructの値が取得したい
                struct temp_struct {
                  char a;
                  int b
                  int c[4];
                };
                temp_struct.b
                ```

                ```
                  ; グローバルで上記の型を宣言
                  %struct_type = type { i8, i32, [4 x i8] }

                  define i32* @test_stuct_gep(%struct_type* %s) {
                    entry:
                      ; 直接field名を指定するのではなく、肩の宣言した順番を記述する
                      ; bは2つ目に宣言したので1
                      %ret_val = getelementptr %struct_type, %struct_type* %s, i32 0, i32 1
                      ret i32* %ret_val
                  }
                ```
              </section>

              <section style="text-align:left;" data-markdown>
                  ### LLVM IRのGEP

                  ```
                  ; 型, 型のポインタ 変数, index1, index2, ...(以下状況によって変更)
                  getelementptr %[12 x i8], %[12 x i8]* %local_str, i32 0, i32 0
                  ```

                  常にindex1が0にならない…?
              </section>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 50px; font-weight:bold;">llvm-c apiではどうなっている</p>
            #### 主に3つ提供されている様子
            - LLVMBuildGEP
            - LLVMBuildInBoundsGEP(存在しないアドレスを参照した際にエラーになる)
            - LLVMBuildStructGEP

            LLVMBuildInBoundsGEPについて説明する
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">LLVMBuildInBoundsGEP</p>
            リファレンス見ても初見では全く分からなかったので、雑にまとめます

            2と3については次のスライドで詳しく

            1. llvm builderのref
            1. StructsやArraysのvalueのref
            1. 参照するIndexのArrayをllvm value
            1. 3のlength
            1. 作成する変数名(空文字だと自動生成)
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">default loaderの前に実行されるoptionalなloader</p>


            ~~~js
              let abc = [0, 1, 2, 3];

            ~~~


          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">値を返すとdefault loaderまで処理が省略される</p>

            ~~~js
            module.exports = {
              pitch: function() {
                // 値を返すとdefaultまで処理が省略される
                // 返せる値はStringかBuffer
                return 'something'

                // 非同期なら 
                // const callback = this.async();
                // callback(null, 'something');

                // return      何も返さない(undefind)ならば次のloaderの処理に移る
              }
              default: function(sources) {
                return sources[0]   // Arrayで来るので単純にreturnしているのみ
              }
            }
            ~~~
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">値を返すとdefault loaderまで処理が省略される</p>

            <p>例1</p>

            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">abc-loader.pitch</p><p>return "abc"</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">def-loader.pitch</p><p>(省略)</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">def-loader.loader</p><p>(省略)</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">abc-loader.loader</p><p>(省略)</p></div>  
          </script>
        </section>


        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">値を返すとdefault loaderまで処理が省略される</p>

            <p>例2</p>

            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">abc-loader pitch</p><p>return</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">def-loader pitch</p><p>return "somethingA"</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">def-loader default</p><p>(省略)</p></div>
            <div style="display:flex; height:60px; padding-bottom:10px; background-color:#777; width:100%;"><p style="width:50%;">abc-loader default</p><p>return "somethingB"</p></div>
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">値を返すとdefault loaderまで処理が省略される</p>
            
            <div style="display:flex; ">
              <p style="display:block; width:15%;">使用例</p><p>cache-loader</p>
            </div>

            1. pitch loaderでcacheと依存ファイルのmtimeを比較
            2. 差異がない場合はcacheを読みこみreturn
            3. defalult loaderでそれまでの生成物と依存ファイルのpath、mtimeからcacheを作成
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">値を返すとdefault loaderまで処理が省略される</p>

            <p>mtime … 最終変更時刻 (modify time)</p>
            <p>最後にファイルを変更した時刻のこと</p>
            <p>正確にはファイルにwrite(2)、またはtruncate(2)した場合に変更されるもの</p>
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">この時点ではまだソースは読み込まれていない</p>

            - pathは取得できるので取得はできる(非推奨)
            - loader-utilsやschema-utilsは使用できるのでoptionなどは取得できる
            - 第3引数経由で他のloaderに値を渡すことはできる
          </script>
        </section>

      <section style="text-align:left;" data-markdown>
          <script type="text/template">
            <p style="font-size: 40px; font-weight:bold;">この時点ではまだソースは読み込まれていない</p>

            - 正直cache-loaderくらいしか第3引数を使っているloaderを見かけない
            - cacheの依存情報やfileがコンパイル中に変更されていないか確認するために使用している
            - そもそもpitch loader自体ほとんど使われてない(script-loader, style-loaderとか)
          </script>
        </section>

        <section style="text-align:left;" data-markdown>
          <script type="text/template">
            ### まとめ

            <p style="font-size: 40px; font-weight:bold;">使う機会はあるのか?</p>

            - webpackに対してはないかもしれない
            - しかしフェイズを2つに分けて、片方ではcache管理などを行うという設計の仕方は使えそう
            - ~~まぁその時楽しめれば良いよね~~
            - [awesome-prettier-loader](https://github.com/rchaser53/awesome-prettier-loader)が作成できた!
          </script>
        </section>

				<section style="text-align:left;">
          <p>参考リンク</p>
          <p>
            <a href="https://webpack.js.org/contribute/writing-a-loader/">公式ページ(かなり充実している)</a>
          </p>
          <p>
            <a href="https://github.com/webpack/webpack/issues/360">Documentation for pitch vs normal loader isn't very clear</a>
          </p>
          <p>
            <a href="http://x68000.q-e-d.net/~68user/unix/pickup?%A5%BF%A5%A4%A5%E0%A5%B9%A5%BF%A5%F3%A5%D7">UNIX/Linuxの部屋 用語集:タイムスタンプ</a>
          </p>
          <p>
            <a href="https://github.com/webpack-contrib/cache-loader/blob/master/src/index.js">cache-loader</a>
          </p>
        </section>

				<section style="text-align:left;">
					<h2>ご静聴ありがとうございました!</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
